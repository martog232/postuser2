import * as i0 from '@angular/core';
import { Injectable, Component, ViewEncapsulation, EventEmitter, ChangeDetectionStrategy, Input, Output, ViewChild, NgModule } from '@angular/core';
import { Terminal } from 'xterm';
import { FitAddon } from 'xterm-addon-fit';
import { Subject } from 'rxjs';
import { ResizeObserver } from '@juggle/resize-observer';
import * as i2 from 'angular-resizable-element';
import { ResizableModule } from 'angular-resizable-element';
import * as i3 from '@angular/common';
import { CommonModule } from '@angular/common';

class NgTerminalService {
    constructor() { }
}
NgTerminalService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NgTerminalService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
NgTerminalService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NgTerminalService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NgTerminalService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root'
                }]
        }], ctorParameters: function () { return []; } });

class GlobalStyleComponent {
    constructor() { }
    ngOnInit() {
    }
}
GlobalStyleComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: GlobalStyleComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
GlobalStyleComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: GlobalStyleComponent, selector: "global-style", ngImport: i0, template: "", styles: [".xterm{position:relative;user-select:none;-ms-user-select:none;-webkit-user-select:none}.xterm.focus,.xterm:focus{outline:none}.xterm .xterm-helpers{position:absolute;top:0;z-index:5}.xterm .xterm-helper-textarea{padding:0;border:0;margin:0;position:absolute;opacity:0;left:-9999em;top:0;width:0;height:0;z-index:-5;white-space:nowrap;overflow:hidden;resize:none}.xterm .composition-view{background:#000;color:#fff;display:none;position:absolute;white-space:nowrap;z-index:1}.xterm .composition-view.active{display:block}.xterm .xterm-viewport{background-color:#000;overflow-y:scroll;cursor:default;position:absolute;right:0;left:0;top:0;bottom:0}.xterm .xterm-screen{position:relative}.xterm .xterm-screen canvas{position:absolute;left:0;top:0}.xterm .xterm-scroll-area{visibility:hidden}.xterm-char-measure-element{display:inline-block;visibility:hidden;position:absolute;top:0;left:-9999em;line-height:normal}.xterm{cursor:text}.xterm.enable-mouse-events{cursor:default}.xterm.xterm-cursor-pointer,.xterm .xterm-cursor-pointer{cursor:pointer}.xterm.column-select.focus{cursor:crosshair}.xterm .xterm-accessibility,.xterm .xterm-message{position:absolute;left:0;top:0;bottom:0;right:0;z-index:10;color:transparent}.xterm .live-region{position:absolute;left:-9999px;width:1px;height:1px;overflow:hidden}.xterm-dim{opacity:.5}.xterm-underline{text-decoration:underline}.xterm-strikethrough{text-decoration:line-through}.xterm-screen .xterm-decoration-container .xterm-decoration{z-index:6;position:absolute}\n"], encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: GlobalStyleComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'global-style',
                    templateUrl: './global-style.component.html',
                    styleUrls: ['../../../../../node_modules/xterm/css/xterm.css'],
                    encapsulation: ViewEncapsulation.None
                }]
        }], ctorParameters: function () { return []; } });

class NgTerminalComponent {
    constructor(renderer, ref, hostRef) {
        this.renderer = renderer;
        this.ref = ref;
        this.hostRef = hostRef;
        this.keyInputSubject = new Subject();
        this.keyEventSubject = new Subject();
        this.requestRenderFromAPI = new Subject();
        this.allLogsSubject = new Subject();
        this.resizableObservers = [];
        this.h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
        this.paddingSize = 5;
        this.stylesForDiv = { 'display': 'block' };
        this._draggableInput = false;
        this._stylesInput = {};
        this.keyInputEmitter = new EventEmitter();
        this.keyEventEmitter = new EventEmitter();
        /**
         * @internal don't make a direct call
         */
        this.releaseNextOne = () => {
            if (!this.interval) {
                let list = this.waitingQueue.splice(0, 1);
                if (list.length == 1) {
                    this.allLogsSubject.next(list[0]);
                }
            }
        };
        /**
         * @internal don't make a direct call
         */
        this.waitingQueue = [];
        this.requestRenderSubscription = this.requestRenderFromAPI.subscribe(change => {
            let changeWithDefault = Object.assign({ rowChanged: false, columnChanged: false }, change);
            this.pushToWaitingQueue(changeWithDefault);
            this.getNextOrWait();
        });
    }
    set _dataSource(ds) {
        if (this.dataSourceSubscription != null) {
            this.dataSourceSubscription.unsubscribe();
        }
        this.dataSource = ds;
        this.dataSourceSubscription = this.dataSource.subscribe((data) => {
            this.write(data);
        });
    }
    get _dataSource() {
        return this.dataSource;
    }
    set draggable(draggable) {
        this._draggableInput = draggable;
        // this.applyStyleToDraggable();
    }
    get draggable() {
        return this._draggableInput;
    }
    setMinWidth(width) {
        this._minWidthInput = width;
    }
    setMinHeight(height) {
        this._minHeightInput = height;
    }
    setDraggable(draggable) {
        this._draggableInput = draggable;
        this.lastDraggedPosition = undefined;
        this.ref.markForCheck();
    }
    setRows(rows) {
        if (this._rowsInput != rows) {
            this._rowsInput = rows;
            this.requestRenderFromAPI.next({ rowChanged: true });
        }
    }
    setCols(cols) {
        if (this._colsInput != cols) {
            this._colsInput = cols;
            this.requestRenderFromAPI.next({ columnChanged: true });
        }
    }
    setStyle(styleObject) {
        var _a;
        if (JSON.stringify((_a = this._stylesInput) !== null && _a !== void 0 ? _a : {}) != JSON.stringify(styleObject !== null && styleObject !== void 0 ? styleObject : {})) {
            this._stylesInput = styleObject;
            this.requestRenderFromAPI.next({});
        }
    }
    getNextOrWait() {
        if (!this.hostRef.nativeElement.isConnected) {
            this.stopAndPolling();
        }
        else {
            this.releaseNextOne();
        }
    }
    pushToWaitingQueue(item) {
        this.waitingQueue.push(item);
        this.releaseNextOne();
    }
    /**
     * @internal
     */
    stopAndPolling() {
        const pollFunction = () => {
            if (this.interval)
                return;
            const interval = setInterval(() => {
                if (this.hostRef.nativeElement.isConnected) {
                    clearInterval(interval);
                    this.interval = undefined;
                    this.releaseNextOne();
                }
            }, 500);
            this.interval = interval;
        };
        pollFunction();
    }
    observableSetup() {
        this.term.onData((input) => {
            this.keyInputSubject.next(input);
        });
        this.term.onKey(e => {
            this.keyEventSubject.next(e);
        });
        this.keyInputSubjectSubscription = this.keyInputSubject.subscribe((data) => {
            this.keyInputEmitter.emit(data);
        });
        this.keyEventSubjectSubscription = this.keyEventSubject.subscribe((e) => {
            this.keyEventEmitter.emit(e);
        });
        this.resizableObservers = [this.observeTerminalDimension(), this.observeHostDimension()];
        this.allLogsSubjectSubscription = this.allLogsSubject.subscribe((change) => {
            if (change)
                this.coordinateOuterAndTerminal(change);
            else
                this.coordinateOuterAndTerminal(change);
            this.getNextOrWait();
        });
        this.getNextOrWait();
    }
    /**
     * set dimensions
     */
    setOuterDimensions(left, top, width, height) {
        this.requestRenderFromAPI.next({
            rowChanged: false, columnChanged: false,
            dragged: { draggedWidth: `${width}px`, draggedHeight: `${height}px` }
        });
    }
    /**
     * Render is being used for fast rendering without markForCheck().
     */
    applyStyleToDiv() {
        Object.keys(this.stylesForDiv).map(key => {
            return { key, value: this.stylesForDiv[key] };
        }).forEach(({ key, value }) => {
            if (value)
                this.renderer.setStyle(this.resizeBox.nativeElement, key, value);
            else {
                this.renderer.removeStyle(this.resizeBox.nativeElement, key);
            }
        });
        this.stylesForDiv = this.stylesForDiv; //invalidate
    }
    /**
     * When draggable is true, add border styles
     * Render is being used for fast rendering without markForCheck().
     */
    // private applyStyleToDraggable() {
    //   if (this._draggableInput)
    //     this.renderer.addClass(this.terminalOuter.nativeElement, 'draggable');
    //   else
    //     this.renderer.removeClass(this.terminalOuter.nativeElement, 'draggable');
    // }
    ngOnInit() {
    }
    /**
     * It creates new terminal in #terminal.
     */
    ngAfterViewInit() {
        this.fitAddon = new FitAddon();
        this.term = new Terminal();
        this.term.open(this.terminalOuter.nativeElement);
        this.term.loadAddon(this.fitAddon);
        this.observableSetup();
        this.requestRenderFromAPI.next({});
    }
    ngOnChanges(changes) {
        var _a, _b, _c, _d;
        console.group("onChanges");
        console.debug('prop: ', changes);
        console.groupEnd();
        if (changes === null || changes === void 0 ? void 0 : changes._rowsInput) {
            if (((_a = changes === null || changes === void 0 ? void 0 : changes._rowsInput) === null || _a === void 0 ? void 0 : _a.previousValue) != ((_b = changes === null || changes === void 0 ? void 0 : changes._rowsInput) === null || _b === void 0 ? void 0 : _b.currentValue)) {
                this.requestRenderFromAPI.next({ rowChanged: true });
            }
        }
        if (changes === null || changes === void 0 ? void 0 : changes._colsInput) {
            if (((_c = changes === null || changes === void 0 ? void 0 : changes._colsInput) === null || _c === void 0 ? void 0 : _c.previousValue) != ((_d = changes === null || changes === void 0 ? void 0 : changes._colsInput) === null || _d === void 0 ? void 0 : _d.currentValue)) {
                this.requestRenderFromAPI.next({ columnChanged: true });
            }
        }
        // this.requestRenderFromAPI.next({});
    }
    /**
     * It must be called after having initialized the terminal.
     * xterm fit
     * @param rowColChange
     * @returns
     */
    coordinateOuterAndTerminal(changeList) {
        var _a, _b;
        console.debug(`changeList: ${JSON.stringify(changeList)}`);
        // apply a style input while keeping width and height default
        this.stylesForDiv = Object.assign(Object.assign(Object.assign({}, this.stylesForDiv), this._stylesInput), { width: this.stylesForDiv.width, height: this.stylesForDiv.height });
        // but if the div is dragged, update width, height
        if (changeList.dragged) {
            this.stylesForDiv.width = changeList.dragged.draggedWidth;
            this.stylesForDiv.height = changeList.dragged.draggedHeight;
            this.lastDraggedPosition = { width: changeList.dragged.draggedWidth, height: changeList.dragged.draggedHeight };
        }
        else if (!this._rowsInput && !this._colsInput && !(this.draggable && this.lastDraggedPosition)) {
            // but if the dimension of host element is resized, update width and height
            this.stylesForDiv.width = '100%';
            this.stylesForDiv.height = '100%';
        }
        this.applyStyleToDiv();
        // resize with new cols and rows if they changed.
        if (changeList.rowChanged || changeList.columnChanged) {
            this.term.resize((_a = this._colsInput) !== null && _a !== void 0 ? _a : this.term.cols, (_b = this._rowsInput) !== null && _b !== void 0 ? _b : this.term.rows);
        }
        else {
            // fit() operation doesn't see padding values of terminalOuter.
            // But it uses padding values of terminal element.
            // So we force to set padding values when calling fit() operation for a while.
            this.term.element.style.paddingLeft = `${this.paddingSize}px`;
            this.term.element.style.paddingRight = `${this.paddingSize}px`;
            this.fitAddon.fit();
            this.term.element.style.padding = '0px';
        }
        // coordinate difference between terminal and outer
        let xtermScreen = this.term.element.getElementsByClassName('xterm-screen')[0];
        let xtermViewport = this.term.element.getElementsByClassName('xterm-viewport')[0];
        const terminalWidth = xtermScreen.clientWidth;
        const terminalHeight = xtermScreen.clientHeight;
        const core = this.underlying._core;
        const scrollWidth = core.viewport.scrollBarWidth;
        // It fixes that the viewport's width doesn't changes after calling fit()
        this.renderer.setStyle(xtermViewport, 'width', `${terminalWidth + scrollWidth}px`);
        console.debug(terminalWidth + scrollWidth + this.paddingSize * 2, terminalWidth, scrollWidth, this.paddingSize * 2); // + borderWidth * 2
        console.debug(terminalHeight + this.paddingSize * 2, terminalHeight);
        this.stylesForDiv = Object.assign(Object.assign({}, this.stylesForDiv), { width: `${terminalWidth + scrollWidth + this.paddingSize * 2}px`, height: `${terminalHeight + this.paddingSize * 2}px` });
        this.applyStyleToDiv();
        this.ref.markForCheck();
    }
    observeTerminalDimension() {
        let viewport = this.terminalOuter.nativeElement.querySelector('.xterm-viewport');
        if (viewport) {
            const resizeObserver = new ResizeObserver(entries => {
                const divWidth = parseFloat(getComputedStyle(this.terminalOuter.nativeElement).width);
                const divHeight = parseFloat(getComputedStyle(this.terminalOuter.nativeElement).height);
                let width = undefined;
                let height = undefined;
                for (let entry of entries) {
                    if (entry.contentBoxSize) {
                        if (entry.target instanceof HTMLElement) {
                            width = parseFloat(getComputedStyle(entry.target).width);
                            height = parseFloat(getComputedStyle(entry.target).height);
                        }
                    }
                    else {
                        width = parseFloat(getComputedStyle(entry.target).width);
                        height = parseFloat(getComputedStyle(entry.target).height);
                    }
                }
                if (width > divWidth || height > divHeight) {
                    this.requestRenderFromAPI.next({ whenTerminalDimensionIsOverOuterDiv: { width: `${width}px`, height: `${height}px` } });
                }
            });
            resizeObserver.observe(viewport);
            return resizeObserver;
        }
        else {
            console.error("Invalid state is detected. xterm element should exist below .terminal-outer.");
        }
    }
    observeHostDimension() {
        let hostElement = this.hostRef.nativeElement;
        if (hostElement) {
            const resizeObserver = new ResizeObserver(entries => {
                let width = undefined;
                let height = undefined;
                for (let entry of entries) {
                    if (entry.contentBoxSize) {
                        if (entry.target instanceof HTMLElement) {
                            width = parseFloat(getComputedStyle(entry.target).width);
                            height = parseFloat(getComputedStyle(entry.target).height);
                        }
                    }
                    else {
                        width = parseFloat(getComputedStyle(entry.target).width);
                        height = parseFloat(getComputedStyle(entry.target).height);
                    }
                }
                this.requestRenderFromAPI.next({ hostResized: { width: `${width}px`, height: `${height}px` } });
            });
            resizeObserver.observe(hostElement);
            return resizeObserver;
        }
        else {
            console.error("Invalid state is detected. xterm element should exist below .terminal-outer.");
        }
    }
    /**
     * clean all resources
     */
    ngOnDestroy() {
        if (this.keyInputSubjectSubscription)
            this.keyInputSubjectSubscription.unsubscribe();
        if (this.dataSourceSubscription)
            this.dataSourceSubscription.unsubscribe();
        if (this.keyEventSubjectSubscription)
            this.keyEventSubjectSubscription.unsubscribe();
        if (this.requestRenderSubscription)
            this.requestRenderSubscription.unsubscribe();
        if (this.allLogsSubjectSubscription)
            this.allLogsSubjectSubscription.unsubscribe();
        if (this.interval)
            clearInterval(this.interval);
        if (this.term)
            this.term.dispose();
        this.resizableObservers.forEach(ob => ob.disconnect());
    }
    write(chars) {
        this.term.write(chars);
    }
    get keyInput() {
        return this.keyInputSubject;
    }
    get keyEventInput() {
        return this.keyEventSubject;
    }
    get underlying() {
        return this.term;
    }
    get isDraggableOnEdgeActivated() {
        // return this.displayOption.activateDraggableOnEdge != undefined && this.displayOption.fixedGrid == undefined;
        return this._draggableInput;
    }
    /**
     * After user coordinate dimensions of terminal, it's called.
     * @param left
     * @param top
     * @param width
     * @param height
     */
    onResizeEnd(left, top, width, height) {
        this.setOuterDimensions(left, top, width, height);
    }
    /**
     * Before onResizeEnd is called, it valiates dimensions to change.
     * @param re dimension to be submitted from resizable stuff
     */
    validatorFactory() {
        const comp = this;
        return (re) => {
            var _a, _b;
            // const displayOption = comp.displayOption;
            if (this._draggableInput) {
                let left = re.rectangle.left, top = re.rectangle.top, width = re.rectangle.width, height = re.rectangle.height;
                if ((width < ((_a = this._minWidthInput) !== null && _a !== void 0 ? _a : 100)) || (height < ((_b = this._minHeightInput) !== null && _b !== void 0 ? _b : 50))) {
                    return false;
                }
                else
                    return true;
            }
            else
                return false;
        };
    }
}
NgTerminalComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NgTerminalComponent, deps: [{ token: i0.Renderer2 }, { token: i0.ChangeDetectorRef }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
NgTerminalComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.2.16", type: NgTerminalComponent, selector: "ng-terminal", inputs: { _dataSource: ["dataSource", "_dataSource"], _rowsInput: ["rows", "_rowsInput"], _colsInput: ["cols", "_colsInput"], _minWidthInput: ["minWidth", "_minWidthInput"], _minHeightInput: ["minHeight", "_minHeightInput"], draggable: "draggable" }, outputs: { keyInputEmitter: "keyInput", keyEventEmitter: "keyEvent" }, viewQueries: [{ propertyName: "terminalOuter", first: true, predicate: ["terminal"], descendants: true, static: true }, { propertyName: "resizeBox", first: true, predicate: ["resizeBox"], descendants: true, static: true }], usesOnChanges: true, ngImport: i0, template: "<global-style></global-style>\n<div mwlResizable #resizeBox class=\"resize-box\" [validateResize]=\"validatorFactory()\" [enableGhostResize]=\"true\"\n    (resizeEnd)=\"onResizeEnd($event.rectangle.left, $event.rectangle.top, $event.rectangle.width, $event.rectangle.height)\">\n    <div #terminal class=\"terminal-outer\">\n    </div>\n    <div class=\"resize-handle resize-handle-top\" mwlResizeHandle [ngClass]=\"{'handle-active' : isDraggableOnEdgeActivated}\"\n        [resizeEdges]=\"{ top: false }\"></div>\n    <div class=\"resize-handle resize-handle-left\" mwlResizeHandle [ngClass]=\"{'handle-active' : isDraggableOnEdgeActivated}\"\n        [resizeEdges]=\"{ left: false }\"></div>\n    <div class=\"resize-handle resize-handle-right\" mwlResizeHandle [ngClass]=\"{'handle-active' : isDraggableOnEdgeActivated}\"\n        [resizeEdges]=\"isDraggableOnEdgeActivated ? { right: true } : { right: false }\"></div>\n    <div class=\"resize-handle resize-handle-bottom\" mwlResizeHandle [ngClass]=\"{'handle-active' : isDraggableOnEdgeActivated}\"\n        [resizeEdges]=\"isDraggableOnEdgeActivated ? { bottom: true } : { bottom: false }\"></div>\n</div>", styles: [".terminal-outer{box-sizing:border-box;height:100%;width:100%;padding:5px}:host{display:block;height:100%;width:100%}.resize-box{height:100%;width:100%;position:relative}div>.handle-active{z-index:100;background-color:#85858a}.resize-handle{background-color:#000}.resize-handle-top.handle-active,.resize-handle-bottom.handle-active{cursor:row-resize}.resize-handle-left.handle-active,.resize-handle-right.handle-active{cursor:col-resize}.resize-handle-top,.resize-handle-bottom{position:absolute;height:5px;width:100%}.resize-handle-top{top:0px}.resize-handle-bottom{bottom:0px}.resize-handle-left,.resize-handle-right{position:absolute;height:calc(100%);width:5px}.resize-handle-left{left:0px;top:0px}.resize-handle-right{right:0px;top:0px}\n"], components: [{ type: GlobalStyleComponent, selector: "global-style" }], directives: [{ type: i2.ResizableDirective, selector: "[mwlResizable]", inputs: ["validateResize", "enableGhostResize", "resizeSnapGrid", "resizeCursors", "ghostElementPositioning", "allowNegativeResizes", "mouseMoveThrottleMS"], outputs: ["resizeStart", "resizing", "resizeEnd"], exportAs: ["mwlResizable"] }, { type: i2.ResizeHandleDirective, selector: "[mwlResizeHandle]", inputs: ["resizeEdges", "resizableContainer"] }, { type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NgTerminalComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'ng-terminal',
                    templateUrl: './ng-terminal.component.html',
                    styleUrls: ['./ng-terminal.component.css'],
                    changeDetection: ChangeDetectionStrategy.OnPush
                }]
        }], ctorParameters: function () { return [{ type: i0.Renderer2 }, { type: i0.ChangeDetectorRef }, { type: i0.ElementRef }]; }, propDecorators: { _dataSource: [{
                type: Input,
                args: ['dataSource']
            }], _rowsInput: [{
                type: Input,
                args: ['rows']
            }], _colsInput: [{
                type: Input,
                args: ['cols']
            }], _minWidthInput: [{
                type: Input,
                args: ['minWidth']
            }], _minHeightInput: [{
                type: Input,
                args: ['minHeight']
            }], draggable: [{
                type: Input,
                args: ['draggable']
            }], keyInputEmitter: [{
                type: Output,
                args: ['keyInput']
            }], keyEventEmitter: [{
                type: Output,
                args: ['keyEvent']
            }], terminalOuter: [{
                type: ViewChild,
                args: ['terminal', { static: true }]
            }], resizeBox: [{
                type: ViewChild,
                args: ['resizeBox', { static: true }]
            }] } });

class NgTerminalModule {
}
NgTerminalModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NgTerminalModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgTerminalModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NgTerminalModule, declarations: [NgTerminalComponent, GlobalStyleComponent], imports: [ResizableModule, CommonModule], exports: [NgTerminalComponent] });
NgTerminalModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NgTerminalModule, imports: [[
            ResizableModule, CommonModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.16", ngImport: i0, type: NgTerminalModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgTerminalComponent, GlobalStyleComponent],
                    imports: [
                        ResizableModule, CommonModule
                    ],
                    exports: [NgTerminalComponent]
                }]
        }] });

/**
 *
 * It is a CSI sequences generator
 * https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h2-Functions-using-CSI-_-ordered-by-the-final-character_s_
 */
let CSI = '\x9b';
class FunctionsUsingCSI {
    /**
     *  CSI Ps @  Insert Ps (Blank) Character(s) (default = 1) (ICH).
     *
     * */
    static insertBlank(count) {
        return `${CSI}${count}@`;
    }
    /**
     *  CSI Ps SP @ */
    /**
     *  CSI Ps A  Cursor Up Ps Times (default = 1) (CUU).
     * \x9b3A*/
    static cursorUp(count) {
        return `${CSI}${count}A`;
    }
    /**
     *  CSI Ps SP A */
    /**
     *  CSI Ps B  Cursor Down Ps Times (default = 1) (CUD).
     * \x9b3B */
    static cursorDown(count) {
        return `${CSI}${count}B`;
    }
    /**
     *  CSI Ps C  Cursor Forward Ps Times (default = 1) (CUF).
     * \x9b3C */
    static cursorForward(count) {
        return `${CSI}${count}C`;
    }
    /**
     *  CSI Ps D  Cursor Backward Ps Times (default = 1) (CUB).
     * \x9b3D */
    static cursorBackward(count) {
        return `${CSI}${count}D`;
    }
    /**
     *  CSI Ps E  Cursor Next Line Ps Times (default = 1) (CNL).
     * \x9b3E
     * */
    static cursorNextLine(count) {
        return `${CSI}${count}E`;
    }
    /**
     *  CSI Ps F  Cursor Preceding Line Ps Times (default = 1) (CPL).
     * \x9b3F
     *  */
    static cursorPrecedingLine(count) {
        return `${CSI}${count}F`;
    }
    /**
     *  CSI Ps G  Cursor Character Absolute  [column] (default = [row,1]) (CHA).
     *  \x9b9G
     *  */
    static cursorColumn(count) {
        return `${CSI}${count}G`;
    }
    /**
     *  CSI Ps ; Ps H  Cursor Position [row;column] (default = [1,1]) (CUP).
     * \x9b2;2H
     * */
    static cursorPosition(row, col) {
        return `${CSI}${row};${col}H`;
    }
    /**
     *  CSI Ps I  Cursor Forward Tabulation Ps tab stops (default = 1) (CHT). */
    /**
     *  CSI Ps J  Erase in Display (ED), VT100.
     *      Ps = 0  -> Erase Below (default).
     *      Ps = 1  -> Erase Above.
     *      Ps = 2  -> Erase All.
     *      Ps = 3  -> Erase Saved Lines (xterm).
     * \x9b2J
     *  */
    static eraseInDisplay(category) {
        return `${CSI}${category}J`;
    }
    /**
     *  CSI ? Ps J
     *  Erase in Display (DECSED), VT220.
     *    Ps = 0  -> Selective Erase Below (default).
     *    Ps = 1  -> Selective Erase Above.
     *    Ps = 2  -> Selective Erase All.
     *    Ps = 3  -> Selective Erase Saved Lines (xterm).
     * \x9b?2J
     * */
    static eraseSelectiveThingsInDisplay(category) {
        return `${CSI}?${category}J`;
    }
    /**
     *  CSI Ps K
     *   Erase in Line (EL), VT100.
     *     Ps = 0  -> Erase to Right (default).
     *     Ps = 1  -> Erase to Left.
     *     Ps = 2  -> Erase All.
     * \x9b?1K
     * */
    static eraseInLine(category) {
        return `${CSI}${category}K`;
    }
    /**
     *  CSI ? Ps K
     *    Erase in Line (DECSEL), VT220.
     *      Ps = 0  -> Selective Erase to Right (default).
     *      Ps = 1  -> Selective Erase to Left.
     *      Ps = 2  -> Selective Erase All.
     * \x9b?1K
     * */
    static eraseSelectiveThingsInLine(category) {
        return `${CSI}?${category}K`;
    }
    /**
     *  CSI Ps L  Insert Ps Line(s) (default = 1) (IL).
     * \x9b2L
     *  */
    static insertLines(count) {
        return `${CSI}${count}L`;
    }
    /**
     *  CSI Ps M  Delete Ps Line(s) (default = 1) (DL).
     * \x9b2M
     *  */
    static deleteLines(count) {
        return `${CSI}${count}M`;
    }
    /**
     *  CSI Ps P  Delete Ps Character(s) (default = 1) (DCH).
     * \x9b2P
     *  */
    static deleteCharacter(count) {
        return `${CSI}${count}P`;
    }
    /**
     *  CSI Ps S  Scroll up Ps lines (default = 1) (SU), VT420, ECMA-48.
     * \x9b2S
     *  */
    static scrollUpLines(count) {
        return `${CSI}${count}S`;
    }
    /**
     *  CSI ? Pi ; Pa ; Pv S */
    /**
     *  CSI Ps T  Scroll down Ps lines (default = 1) (SD), VT420.
     * \x9b2T
     * */
    static scrollDownLines(count) {
        return `${CSI}${count}T`;
    }
    /**
     *  CSI Ps ; Ps ; Ps ; Ps ; Ps T */
    /**
     *  CSI > Ps ; Ps T */
    /**
     *  CSI Ps X  Erase Ps Character(s) (default = 1) (ECH).
     * \x9b2X
     *  */
    static eraseCharacters(count) {
        return `${CSI}${count}X`;
    }
}
var KindOfEraseInDisplay;
(function (KindOfEraseInDisplay) {
    KindOfEraseInDisplay[KindOfEraseInDisplay["Below"] = 0] = "Below";
    KindOfEraseInDisplay[KindOfEraseInDisplay["Above"] = 1] = "Above";
    KindOfEraseInDisplay[KindOfEraseInDisplay["All"] = 2] = "All";
    KindOfEraseInDisplay[KindOfEraseInDisplay["SavedLines"] = 3] = "SavedLines";
})(KindOfEraseInDisplay || (KindOfEraseInDisplay = {}));
var KindOfEraseInLine;
(function (KindOfEraseInLine) {
    KindOfEraseInLine[KindOfEraseInLine["Right"] = 0] = "Right";
    KindOfEraseInLine[KindOfEraseInLine["Left"] = 1] = "Left";
    KindOfEraseInLine[KindOfEraseInLine["All"] = 2] = "All";
})(KindOfEraseInLine || (KindOfEraseInLine = {}));

/*
 * Public API Surface of ng-terminal
 */
// export * from './lib/display-option';

/**
 * Generated bundle index. Do not edit.
 */

export { FunctionsUsingCSI, KindOfEraseInDisplay, KindOfEraseInLine, NgTerminalComponent, NgTerminalModule, NgTerminalService };
//# sourceMappingURL=ng-terminal.js.map
